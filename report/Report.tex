% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication
\documentclass[a4paper,10pt]{article}
%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage{ngerman} % in german language if required
\usepackage[nooneline,bf]{caption} % Figure descriptions from left margin
\usepackage{times}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{color}
\usepackage{nameref}
\usepackage{url}
\usepackage{inconsolata}
%\usepackage{paralist}

\input{tcilatex}
%-------------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
\pagestyle{empty}                  % delete footer and header
%------------------------------------------------------------------------------
% Environment definitions
\newenvironment*{mytitle}{\begin{LARGE}\bf}{\end{LARGE}\\}%
\newenvironment*{mysubtitle}{\bf}{\\[1.5ex]}%
\newenvironment*{myabstract}{\begin{Large}\bf}{\end{Large}\\[2.5ex]}%
%-------------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figuerhere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%
%
%\begin{figurehere}
% \centering
% \includegraphics[width=8cm, height=4cm]{./eps/placeholder.eps}
% \caption{Some single-column figure caption.}
% \label{fig:myfigure1}
%\end{figurehere}
%
%\begin{figure*}[t]
%  \centering
% \includegraphics[width=16cm, height=4cm]{./eps/placeholder.eps}
% \caption{Some wide-figure caption.}
% \label{fig:myfigure2}
%\end{figure*}

\makeatletter
\newenvironment{tablehere}{\def\@captype{table}}{}
\newenvironment{figurehere}{\def\@captype{figure}\vspace{2ex}}{\vspace{2ex}}
\makeatother

\newenvironment{packeditems}{
\begin{itemize}
  \setlength{\itemsep}{3pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\newenvironment{packedenum}{
\begin{enumerate}
  \setlength{\itemsep}{3pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\definecolor{lightgreen}{rgb}{0.0,0.7,0.0}
\definecolor{lightblue}{rgb}{0.0,0.0,0.7}
\definecolor{lightgrey}{rgb}{0.6,0.6,0.6}

\newcommand{\icc}{I\textsuperscript{2}C }
\newcommand{\keyword}[1]{\texttt{\textbf{#1}}}

% lstlisting global parameters
\lstset{
	language=C,
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\color{lightblue},
	commentstyle=\color{lightgrey},
	captionpos=b,	% caption at the bottom of listing
	xleftmargin=6pt,
	xrightmargin=6pt,
	framexleftmargin=4pt,
	framexrightmargin=4pt,
	aboveskip=12pt,
	belowskip=12pt
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

% Please use capital letters in the beginning of important words as for example
\begin{mytitle}\icc on a Linux based embedded system\end{mytitle}
\begin{mysubtitle}
Design of a bus driver and a client driver for the Nomadik NHK8815 platform
\end{mysubtitle}
%
% Please do not insert a line here
%
\\
Ghiringhelli Fabrizio\\
Matr. 753368, (fabrizio.ghiringhelli@mail.polimi.it)\\
\hspace{10ex}
\begin{flushright}
\emph{Report for the master course of Embedded Systems}\\
\emph{Reviser: PhD. Patrick Bellasi (bellasi@elet.polimi.it)}
\end{flushright}

Received: September, ?? 2012\\
\hspace{10ex}

\begin{myabstract} Abstract \end{myabstract}
TODO

\vspace{4ex}	% Please do not remove or reduce this space here.
\begin{multicols}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Today Linux is the operating system choice for many computer systems which
include, not only desktop and server supercomputers, but also a wide range of 
special-purpose electronic devices known as embedded systems.
An embedded system is specifically designed to perform a set of designated
activities, and it generally uses custom, heterogeneous processors. This makes
Linux a flexible operating system capable of running on a variety of
architectures, such as ARM, PowerPC, MIPS, SPARC, x86, and many others.

However, this flexibility doesn't come for free. While it's true that the
Linux highly modular architecture facilitates the porting phase, still a
lot of efforts are required to build new kernel components to fully
support the target platform.

A big part of these efforts are in developing the low-level interfaces
commonly referred to as \emph{device drivers}.
A device driver (driver for short) is a piece of software designed to direct
control a specific hardware resource using an hardware-independent well defined
interface.

This paper details the design of two \icc drivers for the Nomadik NHK8815
platform: a client driver for an on-board inertial sensor, presented in
section \ref{sec:i2c_client_driver}, and a bus driver for the Sistem-On-Chip
\icc controller (section \ref{sec:i2c_bus_driver}).

The rest of this section provides an overview of the \icc protocol
(\ref{sec:i2c_protocol_overview}), a brief description of the NHK8815 evaluation
board (\ref{sec:nomadik_nhk8815_platform}), and detail information regarding
the project environment (\ref{sec:project_setup}). Finally, the section
\ref{sec:tools} describes the tools and scripts used throughout the project.



%-------------------------------------------------------------------------------
\subsection{I2C protocol overview}
\label{sec:i2c_protocol_overview}
The Inter-Integrated Circuit, or \icc, is a synchronous master-slave messaging
protocol designed to connect a pool of devices by means of a two-wire bus.
It is a simple and low-bandwidth protocol which allows for short-distance on
board communications, while being extremely modest in its hardware resource
requirements. The original standard specified a standard clock rate of 100KHz.
Later updates to the standard introduced a fast speed of 400KHz and a high speed
of 1.7 or 3.4 MHz.

The \icc bus consists of two bi-directional lines, one line for data (SDA)
and one for clock (SCL), by means of which a single master device can send
informations serially to one ore more slave devices (Figure
\ref{fig:i2c-implementation}).
To prevent any conflict every device hooked up to the bus have its own unique
address. The standard \icc specifies two different addressing schema, 7 and
10 bits, allowing at most 128 and 1024 devices connected at the same time.

\begin{figurehere}
 \centering
 \includegraphics[width=6cm]{./figures/i2c-diagram.png}
 \caption{Sample \icc implementation (adapted from \emph{embedded-lab.com}).}
 \label{fig:i2c-implementation}
\end{figurehere}

Each \icc transaction is always initiated by the master which is in charge of
the bus for the entire duration of the transaction, meaning that it controls the
clock and generates the START and STOP sequences. The start and stop sequences
mark the beginning and the end of a transaction and are the only places where
the SDA line is allowed to change while the SCL is high.

All data are transfered one byte at a time. In 7-bit addressing mode, the slave
address occupies the seven most significant bits of the first byte, with the
least significant bit serving as a read/write flag to indicate whether data
will be written to the slave ('0') or data will be read from the slave ('1').
For every byte received, the slave device sends back an acknowledge bit.
Figure \ref{fig:i2c-implementation} shows an example of a typical \icc
transaction.

The \icc protocol supports multiple masters. In a multi-master environment two
or more masters may simultaneously attempt to initiate a data transfer.
In such a scenario, each master must be able to detect a collision and to follow
the arbitration logic that leeds to the election of a winner master. The winner
master can then safely begin its transaction.
The Nomadik NHK8815 platform, like most system designs, operates in a 
single-master environment.

\begin{figurehere}
 \centering
 \includegraphics[width=8cm]{./figures/i2c-transaction.jpg}
 \caption{Sample \icc transaction (adapted from \emph{www.ermicro/blog}).}
 \label{fig:i2c-transaction}
\end{figurehere}

\emph{The Linux \icc subsystem}\\[6pt]
The Linux kernel \icc framework consists of a core layer where resides all the
routines and data structures available to bus drivers and client drivers
(figure \ref{fig:linux-i2c-subsystem}).
The core also provides a level of indirection that allows the underlying drivers
to change from one system to another without affecting \icc subsystem that
relies on them.

This philosophy of a core layer and its attendant benefits is an example of how
Linux helps portability. For instance, enabling \icc on a new platform (which is
precisely the objective of this project) requires only to design the
hardware-dependent components, namely the bus driver and the client drivers,
whereas the core layer needs not to be changed.

\begin{figurehere}
 \centering
 \includegraphics[width=7.5cm]{./figures/linux-i2c-subsystem.png}
 \caption{The Linux \icc subsystem (reprinted from \cite{venkateswaran2008eldd},
 		p. 236).}
 \label{fig:linux-i2c-subsystem}
\end{figurehere}



%-------------------------------------------------------------------------------
\subsection{The Nomadik NHK8815 platform}
\label{sec:nomadik_nhk8815_platform}
The NHK8815 is a full-featured evaluation board for the ST Microelectronics
Nomadik STn8815 (figure \ref{fig:nomadik-nhk8815}). It is a fan-less embedded
computer equipped with a wide range of peripheral devices including USB, UART,
LAN, WLAN, Bluetooth, FM radio, SIM card reader, SD/MMC card reader, color LCD
with touch screen controller, key-pad, video encoder, audio codec, FM radio,
three-axis accelerometer, etc..

\begin{figurehere}
 \centering
 \includegraphics[width=8cm]{./figures/nomadik-nhk8815.jpg}
 \caption{The Nomadik NHK8815 evaluation board.}
 \label{fig:nomadik-nhk8815}
\end{figurehere}

The core of the board is the Nomadik STn8815 multimedia application processor.
The STn8815 is a \emph{System On Chip} that combines an ARM9 core up to 332MHz
with level-two cache to audio, video, imaging and graphics accelerators.

Among other interfaces, the STn8815 integrates two \icc high speed controllers
that support the physical and data-link layer of the \icc protocol.
Below is a list of the \icc controllers' main features:
\begin{packeditems}
	\item Slave transmitter/receiver and master transmitter/receiver modes.
	\item Standard (100kHz), fast (400kHz) and high-speed (3,4MHz) baud rates.
	\item 7-bit or 10-bit addressing.
	\item Compliance with \icc standards.
\end{packeditems}

In a traditional \icc bus topology such as the one in figure
\ref{fig:i2c-implementation}, the STn8815 \icc embedded controller plays the
role of the master. In order for the controller to access the \icc bus, a
corresponding driver must be implemented and registered with the \icc
subsystem. This step is covered in section \ref{sec:i2c_bus_driver},
"\nameref{sec:i2c_bus_driver}."

Because on the NHK8815 evaluation board the majority of the on-board peripheral
devices is connected to the STn8815 \icc bus 0, in this project I focus the
attention on this bus rather than on bus 1.
The table \ref{table:i2c-device-addresses} reports the list of devices on 
the \icc bus 0, with their 7-bit address.
Just like for the case of the bus driver, in order for each slave device
to function a corresponding driver must be registred to the \icc subsystem.
My choice for this project was the LIS3LV02DL, a MEMS inertial sensor mapped
at the address 1D on the Nomadik board.
The design of the LIS3LV02DL driver is detailed in section
\ref{sec:i2c_client_driver}, "\nameref{sec:i2c_client_driver}."\\[6pt]

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l l c}
		\hline
		Device type & Description & 7-bit address \\
		\hline
		STw5095 & Stereo audio codec & 1A \\
		LIS3LV02DL & Inertial sensor & 1D \\
		STw8009 & Video digital encoder	 & 21 \\
		TDA8023TT & Smart Card interface & 22,23 \\
		STw4811 & Power management & 2D \\
		STMPE2401 & Port expanders & 43,44 \\
		TSC2003IPW & Touch screen controller & 48 \\
		STw4102 & Battery charger & 70 \\
		\hline
	\end{tabular}
	\caption{NHK8815 \icc device address map.}
	\label{table:i2c-device-addresses}
\end{tablehere}



%-------------------------------------------------------------------------------
\subsection{Project setup}
\label{sec:project_setup}

The first step to the project is to get the Linux kernel source and to configure
it for the target board. Instead of  using a vendor supplied kernel such as like
STLinux, my personal strategy for this project was to work with the official
kernel from \emph{www.kernel.org}.
This decision was motivated by the need to keep the development process as neat
as possible, and to avoid performing tasks that are not strictly concerned with
the project.

It should be noted that the official kernel offers only limited support for the
Nomadik  NHK8815 platform.
This includes basic definitions and register addresses, interrupt management,
resource definitions and timers. The \icc interface can be used through the
generic drivers \emph{i2c-gpio} and \emph{i2c-algo-bit}, but no one of the
NHK8815 \icc slave devices is provided.

I cloned the git repository at kernel.org on a local machine folder
located \underline{outside} the project workspace. From the tag \emph{3.3}
I created a new branch called \emph{i2cdevel}, where to commit the kernel updates.
I generated one patch per commit. All patches are numbered in sequence and
stored in a folder \underline{inside} the project workspace called
\emph{linux-3.3.0-patches}.

One benefit of this approach is that the project workspace, which is a git
repository as required, also holds all the data needed to obtain the modified
kernel from the official one.
Table \ref{table:project-dir-layout} shows the project workspace layout.
In addition, to ease the project management I defined a set of environmental
variables. A list of them with their definition is presented in table
\ref{table:project-env-variables}.

Finally, a note about the root filesystem. It was built using BusyBox
version 1.18.4 (\cite{busybox}). More precisely, I used a tool called
\textbf{bbfs 1.3}, developed by \emph{Alessandro Rubini} and released under
GNU GPL license (see \cite{bbfs1.3} for details).\\

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l p{5.5cm}}
		\hline
		Variable & Decription \\
		\hline
		\texttt{PRJROOT} & The project root directory\\
		\texttt{KERNELDIR} & The root directory of the kernel source tree \\
		\texttt{PATCHESDIR} & The \emph{linux-3.3.0-patches} directory \\
		\texttt{ROOTFS} & The directory where is stored the target root
			filesystem \\
		\texttt{MODULESDIR} & The directory for temporary holding of the
			loadable driver modules \\
		\hline
	\end{tabular}
	\caption{Project environmental variables.}
	\label{table:project-env-variables}
\end{tablehere}


\begin{table*}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{p{5cm} p{11cm}}
		\hline
		Directory & Content \\
		\hline
		\texttt{linux-3.3.0-patches} & The patches to the Linux kernel and the 
			kernel configuration file \emph{.config}\\
		\texttt{drivers} & The bus driver and slave driver (one subfolder per
			each driver) \\
		\texttt{report} & The \LaTeX sources of this paper \\
		\texttt{script} & Shell scripts (copied to the root directory of the
			target filesystem) \\
		\texttt{tools} & User-space programs to evaluate the drivers (copied to
			the root directory of the target filesystem) \\
		\texttt{images} & The binary image of the kernel and the root
			filesystem \\
		\hline
	\end{tabular}
	\caption{Project directory layout.}
	\label{table:project-dir-layout}
\end{table*}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{I2C client driver}
\label{sec:i2c_client_driver}

This section describes the design of the driver for the LIS3LV02DL inertial
sensor which equips the NHK8815 evaluation board.
The LIS3LV02DL is a three axes linear accelerometer that provides the measurement acceleration signals to the external world through an \icc interface.
The LIS3LV02DL driver was written before the bus driver. Its debug was possible
by using the gpio-based \icc bus driver available in the original kernel. Once
completed and tested, the LIS3LV02DL driver was then used for debugging the new
STN8815 \icc bus driver.\\



%-------------------------------------------------------------------------------
\subsection{Initialization and probing}
\label{sec:lis3_init_probe}

During initialization the driver registers itself with the \icc core. This
is achieved by populating a \keyword{struct i2c\_driver} and passing it
as argument to the function \keyword{i2c\_add\_driver()} as shown below.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers=left,
	caption = {Registration of the LIS3LV02DL driver
		(from \emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-i2cdrv-registration}
]
/* Device and driver names */
#define	DEVICE_NAME		"lis3lv02d"

/* I2C client structure */
static struct i2c_device_id lis3lv02d_idtable[] = {
  { DEVICE_NAME, 0 },
  {}
};
MODULE_DEVICE_TABLE(i2c, lis3lv02d_idtable);

static struct i2c_driver lis3lv02d_driver = {
  .driver   = {
    .name = DRIVER_NAME
  },
  .probe    = lis3lv02d_probe,
  .remove   = __devexit_p(lis3lv02d_remove),
  .id_table = lis3lv02d_idtable,
};

/* Module init */
static int __init lis3lv02d_init(void)
{
  return i2c_add_driver(&lis3lv02d_driver);
}
\end{lstlisting}

The structure \keyword{i2c\_driver} holds pointers to the probe function
and to the remove function that are executed respectively on device probing
and when the device is removed (if ever).
The \keyword{id\_table} member of the structure \keyword{i2c\_driver} informs
the \icc framework about which slave devices are supported by the driver.
In this case the only chip supported is named \keyword{lis3lv02d}.
The names of the supported devices are important for \emph{binding}, as
explained next.

The binding process consists of associating a device with a driver that can
control it. In embedded systems where the number of the \icc bus and the
devices connected to it are known for a fact, it is possible to declare in
advance the \icc slaves which live on the bus. This is typically done in the
board setup file, as shown below.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Registration of the I2C devices (from \emph{board-nhk8815.c}).},
	label = {list:lis3-i2cdev-declaration}
]
/* I2C devices */
static struct i2c_board_info nhk8815_i2c_devices[] = {
  {
    I2C_BOARD_INFO("lis3lv02d", 0x1D),
    .irq = NOMADIK_GPIO_TO_IRQ(82),
    /* No platform data: use driver defaults */
  },
};

static void __init nhk8815_platform_init(void)
{
  ...
  /* Register I2C devices on bus #0 (scl0, sda0) */
  i2c_register_board_info(0, nhk8815_i2c_devices,
    ARRAY_SIZE(nhk8815_i2c_devices));
  ...
}
\end{lstlisting}

The \keyword{nhk8815\_platform\_init} function is executed on board startup
and, among other tasks, registers the \icc slave devices by invoking the
\keyword{i2c\_register\_board\_info} function with arguments that specify
the number of the bus (zero in this case) and the devices connected with it.
This is done through an array of \keyword{struct i2c\_board\_info}, each item
of which specifies the device name and the device address, with the former that
must match with the name registered by the driver in order for binding to succeed.
In this case \keyword{struct i2c\_board\_info} holds only one item which
corresponds to the LIS3LV02DL inertial sensor. Seeing that this sensor's chip
has an interrupt line tied to the cpu (gpio 82), the \keyword{irq} member is
also specified with the respective IRQ number. By means of another member
called \keyword{platform\_data} it is possible to define custom data for the
driver; if not specified like in this case, the driver uses its default
settings, as explained in section \ref{sec:lis3_settings}.

During boot the kernel looks for any \icc driver that has registered a matching
device name, that is "lis3lv02d". Upon finding such a driver, the kernel
ivokes its \keyword{probe()} function passing a pointer to the LIS3LV02DL
device as a parameter. This process is called \emph{probing}.

The probe function is responsible for the per-device initialization, that is
initializing hardware, allocating resources, and registering the device with
any appropriate subsystems. More in detail, the LIS3LV02DL probe function
takes the following actions:
\begin{packedenum}
	\item Allocate memory for a \keyword{struct lis3lv02d\_priv} private data
		structure.
	\item Load the device settings.
	\item Idendify the LIS3LV02DL chip.
	\item Configure the device hardware.
	\item Create the per-device sysfs nodes.
	\item If the free-fall feature is enadled, request the interrupt and
		register the IRQ for the free-fall detection.
	\item If the device polling feature is enabled, register the device with
		the input subsystem.
\end{packedenum}
On successful completion of all the above steps, meaning a successful probing,
the device is bound to the driver.


%-------------------------------------------------------------------------------
\subsection{Sysfs interface}
\label{sec:lis3_sysfs}

Sysfs is an in-memory virtual filesystem that provides a view of the kernel's
structured device model. It offers a convenient yet simple way to implement
functionality as sysfs attribute in the appropriate directory. An attribute
provides a way to map kernel data to files in sysfs: a single attribute maps to
a single file which can be readable, writable or both, depending on which
functionality it exports.

A driver wishing to use sysfs needs to register the sysfs attributes and implement
their respective functions. The table \ref{table:lis3-sysfs-attributes} shows
the list of sysfs nodes handled by the LIS3LV02DL driver. They are located in
\keyword{/sys/devices/platform/lis3lv02d/}.

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l c p{4cm}}
		\hline
		Attribute & Access & Function \\
		\hline
		\texttt{position} & r & Show the acceleration along the x,y,z axis \\
		\hline
		\texttt{enable} & r & Show the enable status of the device \\
						& w & Enable/disable the device \\
		\hline
		\texttt{ff\_enable} & r & Show the enable status of the free-fall 
					 			  feature \\
		\hline
		\texttt{poll\_enable} & r & Show the enable status of the polling
									feature \\
							  & w & Enable/disable the device polling \\
		\hline
		\texttt{read} & r & Read the register at the current address \\
					  & w & Set the current address for reading \\
		\hline
		\texttt{write} & w & Write a register. The low byte holds the register
							 value and the high byte holds the register address \\
		\hline
	\end{tabular}
	\caption{LIS3LV02DL sysfs attributes.}
	\label{table:lis3-sysfs-attributes}
\end{tablehere}

The figure \ref{fig:lis3-sysfs} shows a
dump of a shell session executed on the target board, providing a short
demonstration of how to play with the LIS3LV02DL sysfs interface.

The \keyword{cat enable} command returned 'n', meaning that the device was
disabled.
Turning the device on is achieved by the command \keyword{echo 1 > enable}.
The \keyword{cat position} command returned the values 56, -4, 1043 which
correspond to to acceleration along the x-axis, y-axis and z-axis measured
in $mg$. \keyword{cat ff\_anable} showed that the free-fall feature is enabled.
Finally, the last two commands perform a reading at the address 0F; the answer
is 3A.
\footnote{0F is the address of the \keyword{WHO\_AM\_I} register which holds
the device identification number (3A for the LIS3LV02DL chip)}.

\begin{figurehere}
 \centering
 \includegraphics[width=7.5cm]{./figures/dump-lis3lv02d-sysfs.png}
 \caption{Example of usage of the LIS3LV02DL sysfs interface.}
 \label{fig:lis3-sysfs}
\end{figurehere}


%-------------------------------------------------------------------------------
\subsection{Device polling}
\label{sec:lis3_poll}

Generally speaking \emph{polling} is a technique in which one device periodically
monitors multiple other devices or makes requests from those devices (e.g. check
their state). In this project's context, the polling device is the target
cpu while the LIS3LV02DL inertial sensor is the device being polled.

To implement the polling feature the LIS3LV02DL driver registers itself with the
kernel's \emph{input subsystem}; this involves registering \keyword{open()},
\keyword{close()} and \keyword{poll()} call-back functions, specifying
the polling interval, setting up the type of events involved, etc.
The input subsystem takes care of calling the \keyword{poll()} function at the
specified rate, registering any event notification reported by the driver and
dispatching it to the user-space via sysfs in
\keyword{/dev/input/eventX} ('X' is a numeric identifier assigned when the
driver registers with the input core).
A demonstration of how the device polling works is given in the section
\ref{sec:evdev-testing}.

The listing \ref{list:lis3-poll-enable} shows the sequence of instructions
required to registers with the input core. The driver executes them upon
enabling polling. It allocates the input device, installs the callback
function pointers (lines 8-10), programs the ABS events related to the x,y,z
acceleration data (lines 14-17), and registers the input device (line 26).
Lines 20 through 23 relates to the free-fall feature which is explained in
the next section.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Device registration with the input subsystem
		(from \keyword{lis3lv02d\_poll\_enable()} in
		\emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-poll-enable}
]
struct input_polled_dev *input_polled;
struct input_dev *input;

/* Allocate memory for the input device */
input_polled = input_allocate_polled_device();

/* Setup input parameters */
input_polled->open = lis3lv02d_open;
input_polled->close = lis3lv02d_close;
input_polled->poll = lis3lv02d_poll;
input = input_polled->input;

/* Setup ABS input events */
set_bit(EV_ABS, input->evbit);
set_bit(ABS_X, input->absbit);
set_bit(ABS_Y, input->absbit);
set_bit(ABS_Z, input->absbit);

/* Setup KEY event for free-fall (only if enabled) */
if (priv->ff_enabled) {
  set_bit(EV_KEY, input->evbit);
  set_bit(KEY_FREE_FALL, input->keybit);
}

/* Register input polled device */
input_register_polled_device(input_polled);
\end{lstlisting}

To disable polling the driver unregisters the input device and frees its
previously allocated memory (listing \ref{list:lis3-poll-disable}).

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Device unregistration
		(from \keyword{lis3lv02d\_poll\_disable()} in 
		\emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-poll-disable}
]
/* Unregister input device */
input_unregister_polled_device(priv->input_polled);
input_free_polled_device(priv->input_polled);
\end{lstlisting}

Upon loading the LIS3LV02DL driver, the polling function may be either enabled
or not enabled, depending on whether the default or custom settings were used
(see section \ref{sec:lis3_settings} for details).
Once the driver is up and running, the polling can be enabled/disabled via the
sysfs \keyword{poll\_enable} file, as detailed in the previous section.


%-------------------------------------------------------------------------------
\subsection{Free-fall detection}
\label{sec:lis3_free-fall}
The LIS3LV02DL may be configured to generate an inertial wake-up/free-fall
interrupt signal when a programmable acceleration threshold is crossed at least
in one of the three axes.

The LIS3LV02DL driver installs a threaded ISR to handle the free-fall detection.
Upon receiving an interrupt request the driver reads the acceleration values
from the sensor and notifies an appropriate event to the input core for being
dispatched to the user-space.
Indeed the driver relies on the input subsystem to "inform" the user-space
about a free-fall event. This implies that the device polling be enabled.

Usage of the free-fall feature can be enabled only statically (i.e at compile
time) either by adjusting the driver's defaults or by passing custom settings
from the board initialization code (through \keyword{platfom\_data}).
From user-space the free-fall enable status can be seen via the sysfs
\keyword{ff\_enable} file (see table \ref{table:lis3-sysfs-attributes}).

If the free-fall is enabled, the driver's \keyword{probe()} registers the IRQ
number (as provided by the device) and installs its respective threaded ISR
(lines 10-15 of listing \ref{list:lis3-irq-register}).

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Registration of the free-fall IRQ
		(from \keyword{probe()} in \emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-irq-register}
]
/* Get IRQ (only if free-fall is enabled) */
if (pdata->free_fall_cfg & LIS3_FF_ALL) {
  ...
  /* Register IRQ */
  err = request_threaded_irq(client->irq, NULL,
    lis3lv02d_isr_thread,
    IRQF_TRIGGER_RISING | IRQF_ONESHOT,
    DEVICE_NAME, priv);
  ...
  priv->ff_enabled = true;
}
\end{lstlisting}

The free-fall is notified in form of a KEY event. As for all the input
events this requires two steps: registering with the input subsystem
and reporting upon detection of free-fall.
The former being executed by \keyword{lis3lv02d\_poll\_enable()} (lines 20-23
of listing \ref{list:lis3-poll-enable}), and the latter being handled by the
free-fall ISR as shown below.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Notification of a free-fall KEY event
		(from \keyword{lis3lv02d\_isr\_thread()} in \emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-isr}
]
/* Report free-fall (KEY) event */
input_report_key(input, KEY_FREE_FALL, true);
input_report_key(input, KEY_FREE_FALL, false);
input_sync(input);
\end{lstlisting}


%-------------------------------------------------------------------------------
\subsection{LIS3LV02DL settings}
\label{sec:lis3_settings}

The customization of the LIS3LV02DL settings is done based on \emph{platform data}.
These are data attached to a platform device, that are completely specific to
a given device. It allows the board initialization file to transmit detailed and
custom information about the device to the driver.
In this project's context, the platform data is represented in form of a
\keyword{lis3lv02d\_nhk8815\_platform\_data} structure
(listing \ref{list:lis3-paltform-data}) which allows to set a number of LIS3LV02DL parameters including the acceleration full-range (2g or 6g), free-fall settings,
polling interval, etc..

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {LIS3LV02DL driver's platform data
		(from \emph{lis3lv02d-nhk8815.h}).},
	label = {list:lis3-paltform-data}
]
/* Platform data */
struct lis3lv02d_nhk8815_platform_data {
  unsigned char device_cfg;
  unsigned char free_fall_cfg;
  unsigned int free_fall_threshold;
  unsigned char free_fall_duration;
  unsigned int poll_interval;
}
\end{lstlisting}

The board initialization code may omit to transmit custom data, as it relies on
the driver using its default settings. This is precisely the solution adopted for
this project as shown in listing \ref{list:lis3-i2cdev-declaration}.
One may choose the other way round and set up the \keyword{platform\_data}
member of \keyword{i2c\_board\_info} to point to a 
\keyword{lis3lv02d\_nhk8815\_platform\_data} structure with custom settings.

Upon probing the driver checks whether \keyword{platform\_data} holds a valid
pointer and, if this is the case, loads the custom settings. Otherwise it uses
the default values. The code responsible for this action is reported in listing
\ref{list:lis3-check-platform-data}.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Loading of LIS3LV02DL platform  data
		(\keyword{lis3lv02d\_probe()} in \emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-check-platform-data}
]
/* Save pointer to platform data */
pdata = client->dev.platform_data;
if (!pdata) {
  dev_info(&client->dev,
  "no platform data, using defaults\n");
  pdata = &lis3lv02d_default_init;
}
\end{lstlisting}

In listing \ref{list:lis3-platform-data-defaults} are shown the default settings
for the LIS3LV02DL device as they are defined in \emph{lis3lv02d-nhk8815.c}.

The driver was built as a module and manually loaded into the kernel using the
\keyword{insmod} program. Upon successful load the driver delivers an information
message about its settings to the kernel as shown in figure \ref{fig:lis3-insmod}.
The last command, \keyword{lsmod}, produces the list of modules currently loaded
into the kernel (only \keyword{lis3lv02d-nhk8815} in this example).

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {LIS3LV02DL default setup
		(from \emph{lis3lv02d-nhk8815.c}).},
	label = {list:lis3-platform-data-defaults}
]
/* LIS3LV02DL default configuration */
static const struct lis3lv02d_nhk8815_platform_data
	lis3lv02d_default_init = {

  .device_cfg = LIS3_ODR_40HZ | LIS3_FS_2G,
  .poll_interval = 500,
  .free_fall_cfg = LIS3_FF_XL | LIS3_FF_YL | LIS3_FF_ZL,
  .free_fall_threshold = 600,
  .free_fall_duration = 5,	/* 1/ODR [s] */
};
\end{lstlisting}

\begin{figure*}
% \centering
 \includegraphics[width=11.8cm]{./figures/dump-lis3lv02d-insmod.png}
 \caption{Message showed upon loading LIS3LV02DL module with default settings.}
 \label{fig:lis3-insmod}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{I2C bus driver}
\label{sec:i2c_bus_driver}

As mentioned in section \ref{sec:nomadik_nhk8815_platform} the STn8815 processor
integrates two \icc controllers that can be programmed to work in standard, fast
or high-speed mode. It is designed to operate in a multi-master environment,
either as a master or as a slave. However, because the STn8815 is the only master
on board, and seeing that at this time Linux only operates \icc in master mode, 
the \icc bus driver presented here supports master mode only.


%-------------------------------------------------------------------------------
\subsection{Initialization and probing}
\label{sec:adapter_init_probe}
Initializing and probing the STn8815 \icc bus driver is performed in a similar
way as for LIS3LV02DL client driver (section \ref{sec:lis3_init_probe}), with
the major difference being that the former uses a \emph{platform bus}.

The platform bus requires that any \icc \emph{adapter} (or equivalently
\emph{controller})
\footnote{The two terms are interchangeable in meaning and refer to the
peripheral device that drives the bus (i.e. the master device)}.
which is controlled by the bus driver be registered using a \keyword{platform\_device} structure.
This structure represents the bus adapter and provides information such as the
device name, the device resources and the adapter number, to the bus driver.

Usually the registration of the \icc adapters with the platform bus is
performed by the board initialization file, as the information needed are
highly board specific. And this case is no exception.

The listing \ref{list:i2c-reg-platform-dev} shows the part relevant to this
matter, taken from \emph{arch/arm/mach-nomadik/i2c-8815nhk.c}. Because of the
STn8815 has two \icc adapters, two platform devices need to be defined: one for
bus 0 and one for bus 1.
In this example the former uses the platform data mechanism to customize the
driver settings, while to the latter relies on the driver's defaults
(see section \ref{sec:adapter_settings} for details about the driver settings).

The \keyword{resource} and \keyword{num\_resources} fields allow to define
the device resources (for brevity not shown here). These include the
definition of the memory area (base address and size) and the interrupt number.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Registration of the \icc adapter with the platform bus
		(from \emph{i2c-8815nhk.c}).},
	label = {list:i2c-reg-platform-dev}
]
/* first bus: i2c0 */
static struct platform_device nhk8815_i2c_dev0 = {
  .name		= "stn8815_i2c",
  .id		= 0,
  .resource	= &nhk8815_i2c_resources[0],
  .num_resources = 2,
  .dev		= {
    .platform_data = &nhk8815_i2c_dev0_data,
  },
};

/* second bus: i2c1 */
static struct platform_device nhk8815_i2c_dev1 = {
  .name		= "stn8815_i2c",
  .id		= 1,
  .resource	= &nhk8815_i2c_resources[2],
  .num_resources	= 2,
  /* No platform data: use driver defaults */
};

static int __init nhk8815_i2c_init(void)
{
  ...
  platform_device_register(&nhk8815_i2c_dev0);
  ...
  platform_device_register(&nhk8815_i2c_dev1);
  ...
}
arch_initcall(nhk8815_i2c_init);
\end{lstlisting}

On the driver's side, the registration with the platform bus is achieved by
populating a \keyword{struct  platform\_driver} and passing it to the
macro \keyword{module\_platform\_driver()} as argument (listing
\ref{list:i2c-reg-platform-drv}).
The platform bus simply compares the \keyword{driver.name} member against
the name of each device, as defined in the \keyword{platform\_device} data
structure (listing \ref{list:i2c-reg-platform-dev}); if they are the same
the device matches the driver.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Registration of the \icc bus driver with the platform bus
		(from \emph{i2c-stn8815.c}).},
	label = {list:i2c-reg-platform-drv}
]
#define DRIVER_NAME 	"stn8815_i2c"

static const struct dev_pm_ops stn8815_i2c_pm_ops = {
  SET_RUNTIME_PM_OPS(stn8815_i2c_runtime_suspend,
                     stn8815_i2c_runtime_resume,
                     NULL)
};

static struct platform_driver stn8815_i2c_driver = {
  .probe  = stn8815_i2c_probe,
  .remove = __devexit_p(stn8815_i2c_remove),
  .driver = {
    .name  = DRIVER_NAME,
    .owner = THIS_MODULE,
    .pm	= &stn8815_i2c_pm_ops,
  },
};
module_platform_driver(stn8815_i2c_driver);
\end{lstlisting}

As usual, binding a device to a driver involves calling the driver's 
\keyword{probe()} function passing a pointer to the device as a parameter.
The sequence of operations performed on probing are the following:
\begin{packedenum}
	\item Get the device resource definitions
	\item Allocate the appropriate memory and remap it to a virtual address
		for being accessed by the kernel
	\item Load the device settings.
	\item Configure the device hardware.
	\item Register with the power management system.
	\item Create the per-device sysfs nodes.
	\item Request the interrupt and	register the IRQ.
	\item Set up the \keyword{struct i2c\_adapter} and register the adapter
		with the \icc core.
\end{packedenum}

Once all the above steps successfully complete the driver is bounded to the
devices representing the two STn8815 \icc controllers.


%-------------------------------------------------------------------------------
\subsection{Data transfer}
\label{sec:adapter_data_transfer}

In the Linux \icc subsystem a bus driver consists of an \emph{adapter driver}
and an \emph{algorithm driver}. The motivation behind this further division is
to improve the software reuse and to allow portability. In fact, an algorithm
driver is intended to contain general code that can be used for a whole class
of \icc adapters, while each specific adapter driver either depends on one
algorithm driver, or includes its own implementation.

However, while having a generic algorithm that works for multiple adapters is
suitable for many cases, in embedded systems, where each \icc bus
adapter has its own way of interfacing with the processor and the bus,
it is usual to develop the adapter driver together with its corresponding
algorithm driver. This is also the case of the STn8815 \icc bus driver.

The bus driver registers with the \icc subsystem by using a
\keyword{struct i2c\_adapter} that is instantiated and initialized by the
driver's \keyword{probe()} function, as shown in listing
\ref{list:i2c-adapter-reg}.
The \keyword{i2c\_adapter} structure's \keyword{algo} member is set up to
point to a \keyword{struct i2c\_algorithm} which in turn holds two pointers:
\begin{packeditems}
	\item \keyword{master\_xfer} points to the function that implements the
		actual \icc transmit and receive algorithm.
	\item \keyword{functionality} points to a function that returns the
		features supported by the \icc adapter.
\end{packeditems}

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Registration of the \icc adapter (from \emph{i2c-stn8815.c}).},
	label = {list:i2c-adapter-reg}
]
/* I2C algorithm structure */
static struct i2c_algorithm stn8815_i2c_algo = {
  .master_xfer   = stn8815_i2c_xfer,
  .functionality = stn8815_i2c_func,
};

/* Probe function */
static int __devinit stn8815_i2c_probe
	(struct platform_device *pdev)
{
  ...
  adap = kzalloc(sizeof(struct i2c_adapter),
         GFP_KERNEL);
  ...
  adap->algo = &stn8815_i2c_algo;
  ...
  err = i2c_add_numbered_adapter(adap);
  ...
}
\end{lstlisting}

To communicate with a client the \icc subsystem offers two class of functions:
one for \icc plain communication which includes \keyword{i2c\_master\_send()},
\keyword{i2c\_master\_recv()} and \keyword{i2c\_transfer()}, and a second one
that uses SMBus commands
\footnote{SMBus is a subset of \icc}.
However, whichever method is used, the data transfer relies on the bus driver's
function pointed to by \keyword{master\_xfer}, as the \icc core ultimately calls
this function for the actual transfer to take place.

As shown in listing \ref{list:i2c-adapter-reg}, \keyword{stn8815\_i2c\_xfer()}
is the transfer function installed by the STn8815 \icc bus driver.
This function receives an array of messages as argument and process
them in sequence by calling \keyword{stn8815\_i2c\_xfer\_rd()} or
\keyword{stn8815\_i2c\_xfer\_wr()} depending respectively on whether the message
being processed is marked for read or write.
Once all message have been sent \keyword{stn8815\_i2c\_xfer()} succesfully
returns, otherwise, upon detecting a communication error, aborts the transmission
and returns an appropriate error code.

The STn8815 \icc bus driver uses the STn8815 \icc controller's interrupt
capability to handle the data transfer. More precisely it uses interrupts to
trigger the completion of a transaction and to detect a bus error. Handling
these interrupts is in charge of \keyword{stn8815\_i2c\_isr()} interrupt service
routine (ISR).
Its role is to identify the interrupt source, complete the transaction
by reporting the result to the \emph{task-level}
\footnote{\emph{Task-level} refers to code not running in interrupt context
(as opposed to \emph{interrupt-level})}
function that initiated it (either \keyword{stn8815\_i2c\_xfer\_wr()} or
\keyword{stn8815\_i2c\_xfer\_rd()}), and to clear the interrupt condition from
the \icc controller.

A \emph{completion variable} is used to synchronize between the task-level
function and the ISR. The former initiates the transmission and waits on the
completion variable while the \icc controller performs the transaction; upon
completion, the controller issues an interrupt request which is processed by
\keyword{stn8815\_i2c\_isr()}; once it has accomplished its job, upon returning
from interrupt, \keyword{stn8815\_i2c\_isr()} uses the completion variable to
wake up the task-level function.
Additionally, a timeout is specified to limit the time spent by the task-level
function on waiting on the completion variable.
The whole process is depicted in the sequence diagram of figure
\ref{fig:i2c-trans-seq-diag}.

The listing \ref{list:i2c-completion-sync} shows how the synchronization
mechanism is implemented.
The completion variable is dynamically created and initialized via
\keyword{init\_completion()} (line 7). Afterwards, a call to
\keyword{wait\_for\_completion\_timeout()} (line 11) suspends the task until
either the ISR signals the completion by calling \keyword{complete()} (line 28)
or the timeout expires.  In either case the return value is tested for error
conditions.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {Task-level and ISR synchronization using a completion variable
		(from \emph{i2c-stn8815.c}).},
	label = {list:i2c-completion-sync}
]
/* I2C master read */
static int stn8815_i2c_xfer_rd(
    struct i2c_adapter *adap,
    struct i2c_msg *pmsg, bool stop)
{
  ...
  /* Initialize completion */
  init_completion(&dev->msg_complete);
  ...

  /* Wait for completion */
  i = wait_for_completion_timeout(&dev->msg_complete,
                                  I2C_TIMEOUT);
  if (i < 0)
    return i;
  if (i == 0) {
    dev_err(dev->dev, "Controller timeout\n");
    return -ETIMEDOUT;
  }
  ...
}

/* ISR */
static irqreturn_t stn8815_i2c_isr(int irq,
	void *dev_id)
{
  ...
  /* Complete */
  complete(&dev->msg_complete);
  return IRQ_HANDLED;
}

\end{lstlisting}

\begin{figure*}
 \centering
 \includegraphics[width=16cm]
 	{./figures/i2c-data-transfer-seq-diag.png}
 \caption{Sequence diagram of an \icc transaction.}
 \label{fig:i2c-trans-seq-diag}
\end{figure*}


%-------------------------------------------------------------------------------
\subsection{Power management}
\label{sec:adapter_power_management}

The \icc bus driver relies on the power management infrastructure of the Linux
kernel to achieve run-time power savings. To use this feature the kernel needs
to be configured with "Runtime power management" (\keyword{CONFIG\_PM\_RUNTIME})
option enabled.

The functions that implements the driver's power saving policy are registered
upon registering the driver with the platform bus (refer to listing
\ref{list:i2c-reg-platform-drv} on page \pageref{list:i2c-reg-platform-drv}).
This is done by initializing the \keyword{driver.pm} member of the
\keyword{platform\_driver} structure with a pointer to
\keyword{struct dev\_pm\_ops} which in turn holds the address of the driver's
power management functions.

When the power management subsystem in Linux determines that the \icc adapter
is to be suspended (resumed) it calls \keyword{stn8815\_i2c\_runtime\_suspend()}.
This function simply disables the \icc controller.  
When the adapter is to be resumed, \keyword{stn8815\_i2c\_runtime\_resume()} is called and consequently the \icc controller is re-enabled.

The power management framework creates for the \icc adapter 0 a set of sysfs
nodes that allow to query or modify its power status. They are all located in \keyword{/sys/devices/platform/stn8815\_i2c.0/power/}.

For example, typing \keyword{cat runtime\_status} returns the adapter's power
status, while the command \keyword{echo 'off' > control} disables the adapter's
runtime power management.


%-------------------------------------------------------------------------------
\subsection{\icc bus adapter settings}
\label{sec:adapter_settings}

As for LIS3LV02DL, the \icc bus driver receives custom settings from the board
initialization code via the platform data mechanism.
Looking back at listing \ref{list:i2c-reg-platform-dev}, the adapter 0 uses a
custom setup (line 8), while the adapter 1 relies on the driver's defaults
(line 18).

The platform data of the \icc adapter is defined in \emph{i2c-stn8815.h} and
reported in listing \ref{list:i2c-adapter-platform-data}.
It is represented in form of a \keyword{i2c\_stn8815\_platform\_data} structure
and allows to specify the speed mode (standard, fast or high-speed), 
the bus filtering and the master code.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {STN8815 \icc bus driver's platform data
		(from \emph{i2c-stn8815.h}).},
	label = {list:i2c-adapter-platform-data}
]
/* Platform data */
struct i2c_stn8815_platform_data {
  unsigned char filter;
  unsigned char speed;
  unsigned int  master_code;
}
\end{lstlisting}

The driver loads the platform data on probing and, if not provided, it uses the default setup as defined by \emph{nhk8815\_i2c\_default\_init}
(listing \ref{list:i2c-adapter-data-defaults}).
The figure \ref{fig:i2c-adapter-insmod} shows the information message sent to
the kernel by the driver on successful load.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
	caption = {STN8815 \icc bus adapter default setup
		(from \emph{i2c-stn8815.c}).},
	label = {list:i2c-adapter-data-defaults}
]
/* STN8815-I2C platform data default */
static struct i2c_stn8815_platform_data
	nhk8815_i2c_default_init = {
  .filter	= I2C_STN8815_FILTER_NONE,
  .speed	= I2C_STN8815_SPEED_STANDARD,
  .master_code = 0,
};
\end{lstlisting}

\begin{figure*}
% \centering
 \includegraphics[width=12.4cm, height=1.7cm]{./figures/dump-adapter-insmod.png}
 \caption{Message showed upon loading the STN8815 \icc bus driver module with
 	default settings.}
 \label{fig:i2c-adapter-insmod}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testing}
\label{sec:testing}
% x contesto dei test (remote console)
% x lis3 via /sys (partially already explained in previous sections)
% x lis3 via /dev (evtest)
% - i2c-dev (don't forget citations) using 'i2cexe' tool and i2cprobe script

As I said in section \ref{sec:project_setup} my choice for this project was
to work with the official kernel, which yet lacks many drivers necessary to
fully operate the Nomadik NHK8815 board. Clearly this choice influenced the
way the design process was conducted.
For example, the on-board LCD display and keypad were not used for interfacing
to the system because of the absence of the respective drivers in the kernel.
Instead, I connected to the target board through a serial line (UART) and
interfaced with it using a terminal emulator. This was achieved by configuring
appropriately the bootloader installed on the target, namely U-Boot
(\cite{uboot}).

A number of tools and scripts were used to help testing the drivers throughout
the design process. They all run in user-space and interface with the Linux
kernel, each one using either the \emph{sysfs} interface, the \emph{evdev}
interface or the \emph{i2c-dev} interface.
The figure \ref{fig:whole-driver-system} shows a view of the whole driver
system including the tools mentioned above.
This section describes some simple techniques that allows to test the drivers
using these tools. The tests are classified based on the type of interface 
they rely on.

\begin{figure*}
 \centering
 \includegraphics[width=15cm]{./figures/nhk8815-whole-driver-system.png}
 \caption{The LIS3LV02DL inertial sensor and STn8815 \icc host controller
 	complete driver structure.}
 \label{fig:whole-driver-system}
\end{figure*}


%-------------------------------------------------------------------------------
\subsection{Testing via the \emph{sysfs} interface}
\label{sec:sysfs-testing}
The usage the LIS3LV02DL sysfs interface was previously described in section
\ref{sec:lis3_sysfs}.
This interface turns out to be useful also for debugging activity even
during the early stages of design, when most of the driver functions are yet
to be implemented.
An example of this is represented by the sysfs nodes \keyword{read} and
\keyword{write} which were designed solely to assist debugging (in fact they
are available only if it is defined the constant \keyword{LIS3LV02D\_DEBUG}
in the driver source file). 

\keyword{read} and \keyword{write} together are used in the shell script
\emph{lis3\_read.sh} to implement a simple technique for testing the drivers.
This script allows to read a user defined set of registers of the accelerometer.
It has the following syntax:
\begin{verbatim}
	lis3_read.sh <filename>
\end{verbatim}
where \keyword <filename> refers to a file holding the list of registers with
their respective address. Below is an example of this file (from \emph{lis3\_registers} provided along with the script):

\begin{lstlisting}[language=bash]
# ------------------------------------
# Register name   Register Address
#                   (hex format)
# ------------------------------------
CTRL_REG1               20
CTRL_REG2               21
CTRL_REG3               22
STATUS_REG              27
FF_WU_CFG               30
FF_WU_SRC               31
FF_WU_THS_L             34
FF_WU_THS_H             35
FF_WU_DURATION          36
\end{lstlisting}

For each register in the list \emph{lis3\_read.sh} performs two steps:

\begin{packedenum}
	\item Sets up the address of the register via sysfs \keyword{write}.
	\item Reads the address content via sysfs \keyword{read}.
\end{packedenum}

Below is the output of the script when invoked with \emph{lis3\_registers}
as a command line parameter.

\begin{figurehere}
 \centering
 \includegraphics[width=7cm]{./figures/dump-lis3-read.png}
 \caption{Output of the script \emph{lis3\_read.sh} with \emph{lis3\_registers}
 	as a register file.}
 \label{fig:lis3-read}
\end{figurehere}


%-------------------------------------------------------------------------------
\subsection{Testing via the \emph{evdev} interface}
\label{sec:evdev-testing}

In Linux the directory \emph{/dev} is conventionally used to store the
device files, i.e. files representing interfaces for device drivers. They
allow user programs to access hardware devices through their respective
drivers. Linux classifies drivers in three categories: character, block and
network drivers.

LIS3LV02D driver fits in neither of the above three categories, as it doesn't
create a corresponding device file.
Consequently it's not possible for a user program to directly operate on the
accelerometer via a node in \emph{/dev}.
Instead, upon enabling the device polling, an indirect access is provided by
the \emph{evdev} interface of the input subsystem via a
\keyword{/dev/input/eventX} node.
The accelerometer driver reports the events to the input core, which in turn
writes them to this file in an appropriate format for being processed by a user
program.

An example of such a program is \emph{evtest} \cite{evtest}. It is a free
software released under GNU GPL license and available online in many versions;
1.23 is the one used in this project. This tool allows to display the events
reported by an input device. Below it is shown a sample output from evtest on
the target system.

\begin{figurehere}
 \centering
 \includegraphics[width=8cm]{./figures/dump-evtest.png}
 \caption{Example of usage of \emph{evtest}.}
 \label{fig:evtest-dump}
\end{figurehere}

Initially evtest shows some information about the input device and its supported
event types (Sync, Key and Absolute) then, starting from the line
\keyword{Testing ... (interrupt to exit)}, keeps displaying any data from the
event node.
Since the accelerometer driver terminates each notification by a "sync" event, 
from the sample dump we can identify three distinct groups of events.
Both the first and the second groups represent absolute events corresponding to
the acceleration measured along the three cartesian axes.
The third group regards the free-fall which is reported as a key press
(value 1) and release (value 0) sequence of events.



%-------------------------------------------------------------------------------
\subsection{Testing via the \emph{i2c-dev} interface}
\label{sec:i2c-dev-testing}

The \emph{i2c-dev} interface was designed to allow driving the \icc devices from
user space. Each \icc adapter is assigned a number, say \keyword{X}, and a
corresponding device file is created in \keyword{/dev/i2c-X}.
It is indeed possible for a user mode driver to access an \icc client by
operating the adapter \keyword{X} through its node \keyword{/dev/i2c-X}.

However, in this project the \emph{i2c-dev} interface was used with the only
purpose of testing the \icc bus driver. To this aim I designed a user program
called \emph{i2cexe} which allows to transmit \icc messages to a generic client.
In the above scenario this tool plays the role of a user mode device driver
without effectively being a real driver, as it performs only a single \icc 
transaction (either read or write).

It should be noticed that, as opposed to the previous methods, this test
requires no \icc client driver whatsoever, i.e. the test applies to the \icc bus driver only.
Additionally, the Linux kernel must be configured with with "I2C device interface" (\keyword{CONFIG\_I2C\_DEV}) option enabled.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

TODO.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add all references without citing
\nocite{nxp-i2c-spec}
\nocite{linux-kernel-archive}


% We suggest the use of JabRef for editing your bibliography file (Report.bib)
\bibliographystyle{splncs}
\bibliography{Report}

\end{multicols}
\end{document}
