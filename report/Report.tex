% VDE Template for EUSAR Papers
% Provided by Barbara Lang und Siegmar Lampe
% University of Bremen, January 2002
% English version by Jens Fischer
% German Aerospace Center (DLR), December 2005
% Additional modifications by Matthias Wei{\ss}
% FGAN, January 2009

%-----------------------------------------------------------------------------
% Type of publication
\documentclass[a4paper,10pt]{article}
%-----------------------------------------------------------------------------
% Other packets: Most packets may be downloaded from www.dante.de and
% "tcilatex.tex" can be found at (December 2005):
% http://www.mackichan.com/techtalk/v30/UsingFloat.htm
% Not all packets are necessarily needed:
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
%\usepackage{ngerman} % in german language if required
\usepackage[nooneline,bf]{caption} % Figure descriptions from left margin
\usepackage{times}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{color}
\usepackage{nameref}
\usepackage{url}
\usepackage{inconsolata}

\input{tcilatex}
%-------------------------------------------------------------------------------
% Page Setup
\textheight24cm \textwidth17cm \columnsep6mm
\oddsidemargin-5mm                 % depending on print drivers!
\evensidemargin-5mm                % required margin size: 2cm
\headheight0cm \headsep0cm \topmargin0cm \parindent0cm
\pagestyle{empty}                  % delete footer and header
%------------------------------------------------------------------------------
% Environment definitions
\newenvironment*{mytitle}{\begin{LARGE}\bf}{\end{LARGE}\\}%
\newenvironment*{mysubtitle}{\bf}{\\[1.5ex]}%
\newenvironment*{myabstract}{\begin{Large}\bf}{\end{Large}\\[2.5ex]}%
%-------------------------------------------------------------------------------
% Using Pictures and tables:
% - Instead "table" write "tablehere" without parameters
% - Instead "figure" write "figurehere " without parameters
% - Please insert a blank line before and after \begin{figuerhere} ... \end{figurehere}
%
% CAUTION:   The first reference to a figure/table in the text should be formatted fat.
%
%
%\begin{figurehere}
% \centering
% \includegraphics[width=8cm, height=4cm]{./eps/placeholder.eps}
% \caption{Some single-column figure caption.}
% \label{fig:myfigure1}
%\end{figurehere}
%
%\begin{figure*}[t]
%  \centering
% \includegraphics[width=16cm, height=4cm]{./eps/placeholder.eps}
% \caption{Some wide-figure caption.}
% \label{fig:myfigure2}
%\end{figure*}

\makeatletter
\newenvironment{tablehere}{\def\@captype{table}}{}
\newenvironment{figurehere}{\def\@captype{figure}\vspace{2ex}}{\vspace{2ex}}
\makeatother

\newenvironment{packeditems}{
\begin{itemize}
  \setlength{\itemsep}{3pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\newenvironment{packedenum}{
\begin{enumerate}
  \setlength{\itemsep}{3pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\definecolor{lightgreen}{rgb}{0.0,0.7,0.0}
\definecolor{lightblue}{rgb}{0.0,0.0,0.7}
\definecolor{lightgrey}{rgb}{0.6,0.6,0.6}

\newcommand{\icc}{I\textsuperscript{2}C }
\newcommand{\keyword}[1]{\texttt{\textbf{#1}}}

% lstlisting global parameters
\lstset{
	language=C,
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\color{lightblue},
	commentstyle=\color{lightgrey},
	captionpos=b,	% caption at the bottom of listing
	xleftmargin=6pt,
	xrightmargin=6pt,
	framexleftmargin=4pt,
	framexrightmargin=4pt,
	aboveskip=12pt,
	belowskip=12pt
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

% Please use capital letters in the beginning of important words as for example
\begin{mytitle}\icc on a Linux based embedded system\end{mytitle}
\begin{mysubtitle}
Design of a bus driver and a client driver for the Nomadik NHK8815 platform
\end{mysubtitle}
%
% Please do not insert a line here
%
\\
Ghiringhelli Fabrizio\\
Matr. 753368, (fabrizio.ghiringhelli@mail.polimi.it)\\
\hspace{10ex}
\begin{flushright}
\emph{Report for the master course of Embedded Systems}\\
\emph{Reviser: PhD. Patrick Bellasi (bellasi@elet.polimi.it)}
\end{flushright}

Received: September, ?? 2012\\
\hspace{10ex}

\begin{myabstract} Abstract \end{myabstract}
TODO

\vspace{4ex}	% Please do not remove or reduce this space here.
\begin{multicols}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Today Linux is the operating system choice for many computer systems which
include, not only desktop and server supercomputers, but also a wide range of 
special-purpose electronic devices known as embedded systems.
An embedded system is specifically designed to perform a set of designated
activities, and it generally uses custom, heterogeneous processors. This makes
Linux a flexible operating system capable of running on a variety of
architectures, such as ARM, PowerPC, MIPS, SPARC, x86, and many others.

However, this flexibility doesn't come for free. While it's true that the
Linux highly modular architecture facilitates the porting phase, still a
lot of efforts are required to build new kernel components to fully
support the target platform.

A big part of these efforts are in developing the low-level interfaces
commonly referred to as \emph{device drivers}.
A device driver (driver for short) is a piece of software designed to direct
control a specific hardware resource using an hardware-independent well defined
interface.

This paper details the design of two \icc drivers for the Nomadik NHK8815
platform: a client driver for an on-board inertial sensor, presented in
section \ref{sec:i2c_client_driver}, and a bus driver for the Sistem-On-Chip
\icc controller (section \ref{sec:i2c_bus_driver}).

The rest of this section provides an overview of the \icc protocol
(\ref{sec:i2c_protocol_overview}), a brief description of the NHK8815 evaluation
board (\ref{sec:nomadik_nhk8815_platform}), and detail information regarding
the project environment (\ref{sec:project_setup}). Finally, the section
\ref{sec:tools} describes the tools and scripts used throughout the project.



%-------------------------------------------------------------------------------
\subsection{I2C protocol overview}
\label{sec:i2c_protocol_overview}
The Inter-Integrated Circuit, or \icc, is a synchronous master-slave messaging
protocol designed to connect a pool of devices by means of a two-wire bus.
It is a simple and low-bandwidth protocol which allows for short-distance on
board communications, while being extremely modest in its hardware resource
requirements. The original standard specified a standard clock rate of 100KHz.
Later updates to the standard introduced a fast speed of 400KHz and a high speed
of 1.7 or 3.4 MHz.

The \icc bus consists of two bi-directional lines, one line for data (SDA)
and one for clock (SCL), by means of which a single master device can send
informations serially to one ore more slave devices (Figure
\ref{fig:i2c-implementation}).
To prevent any conflict every device hooked up to the bus have its own unique
address. The standard \icc specifies two different addressing schema, 7 and
10 bits, allowing at most 128 and 1024 devices connected at the same time.

\begin{figurehere}
 \centering
 \includegraphics[width=6cm, height=3.8cm]{./figures/i2c-diagram.png}
 \caption{Sample \icc implementation (adapted from \emph{embedded-lab.com}).}
 \label{fig:i2c-implementation}
\end{figurehere}

Each \icc transaction is always initiated by the master which is in charge of
the bus for the entire duration of the transaction, meaning that it controls the
clock and generates the START and STOP sequences. The start and stop sequences
mark the beginning and the end of a transaction and are the only places where
the SDA line is allowed to change while the SCL is high.

All data are transfered one byte at a time. In 7-bit addressing mode, the slave
address occupies the seven most significant bits of the first byte, with the
least significant bit serving as a read/write flag to indicate whether data
will be written to the slave ('0') or data will be read from the slave ('1').
For every byte received, the slave device sends back an acknowledge bit.
Figure \ref{fig:i2c-implementation} shows an example of a typical \icc
transaction.

The \icc protocol supports multiple masters. In a multi-master environment two
or more masters may simultaneously attempt to initiate a data transfer.
In such a scenario, each master must be able to detect a collision and to follow
the arbitration logic that leeds to the election of a winner master. The winner
master can then safely begin its transaction.
The Nomadik NHK8815 platform, like most system designs, operates in a 
single-master environment.

\begin{figurehere}
 \centering
 \includegraphics[width=8cm, height=3.3cm]{./figures/i2c-transaction.jpg}
 \caption{Sample \icc transaction (adapted from \emph{www.ermicro/blog}).}
 \label{fig:i2c-transaction}
\end{figurehere}

\emph{The Linux \icc subsystem}\\[6pt]
The Linux kernel \icc framework consists of a core layer where resides all the
routines and data structures available to bus drivers and client drivers
(figure \ref{fig:linux-i2c-subsystem}).
The core also provides a level of indirection that allows the underlying drivers
to change from one system to another without affecting \icc subsystem that
relies on them.

This philosophy of a core layer and its attendant benefits is an example of how
Linux helps portability. For instance, enabling \icc on a new platform (which is
precisely the objective of this project) requires only to design the
hardware-dependent components, namely the bus driver and the client drivers,
whereas the core layer needs not to be changed.

\begin{figurehere}
 \centering
 \includegraphics[width=7.5cm, height=6cm]{./figures/linux-i2c-subsystem.png}
 \caption{The Linux \icc subsystem (reprinted from \cite{venkateswaran2008eldd},
 		p. 236).}
 \label{fig:linux-i2c-subsystem}
\end{figurehere}



%-------------------------------------------------------------------------------
\subsection{The Nomadik NHK8815 platform}
\label{sec:nomadik_nhk8815_platform}
The NHK8815 is a full-featured evaluation board for the ST Microelectronics
Nomadik STn8815 (figure \ref{fig:nomadik-nhk8815}). It is a fan-less embedded
computer equipped with a wide range of peripheral devices including USB, UART,
LAN, WLAN, Bluetooth, FM radio, SIM card reader, SD/MMC card reader, color LCD
with touch screen controller, key-pad, video encoder, audio codec, FM radio,
three-axis accelerometer, etc..

\begin{figurehere}
 \centering
 \includegraphics[width=8cm, height=6.35cm]{./figures/nomadik-nhk8815.jpg}
 \caption{The Nomadik NHK8815 evaluation board.}
 \label{fig:nomadik-nhk8815}
\end{figurehere}

The core of the board is the Nomadik STn8815 multimedia application processor.
The STn8815 is a \emph{System On Chip} that combines an ARM9 core up to 332MHz
with level-two cache to audio, video, imaging and graphics accelerators.

Among other interfaces, the STn8815 integrates two \icc high speed controllers
that support the physical and data-link layer of the \icc protocol.
Below is a list of the \icc controllers' main features:
\begin{packeditems}
	\item Slave transmitter/receiver and master transmitter/receiver modes.
	\item Standard (100kHz), fast (400kHz) and high-speed (3,4MHz) baud rates.
	\item 7-bit or 10-bit addressing.
	\item Compliance with \icc standards.
\end{packeditems}

In a traditional \icc bus topology such as the one in figure
\ref{fig:i2c-implementation}, the STn8815 \icc embedded controller plays the
role of the master. In order for the controller to access the \icc bus, a
corresponding driver must be implemented and registered with the \icc
subsystem. This step is covered in section \ref{sec:i2c_bus_driver},
"\nameref{sec:i2c_bus_driver}."

Because on the NHK8815 evaluation board the majority of the on-board peripheral
devices is connected to the STn8815 \icc bus 0, in this project I focus the
attention on this bus rather than on bus 1.
The table \ref{table:i2c-device-addresses} reports the list of devices on 
the \icc bus 0, with their 7-bit address.
Just like for the case of the bus driver, in order for each slave device
to function a corresponding driver must be registred to the \icc subsystem.
My choice for this project was the LIS3LV02D, a MEMS inertial sensor mapped
at the address 1D on the Nomadik board.
The design of the LIS3LV02D driver is detailed in section
\ref{sec:i2c_client_driver}, "\nameref{sec:i2c_client_driver}."\\[6pt]

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l l c}
		\hline
		Device type & Description & 7-bit address \\
		\hline
		STw5095 & Stereo audio codec & 1A \\
		LIS3LV02DL & Inertial sensor & 1D \\
		STw8009 & Video digital encoder	 & 21 \\
		TDA8023TT & Smart Card interface & 22,23 \\
		STw4811 & Power management & 2D \\
		STMPE2401 & Port expanders & 43,44 \\
		TSC2003IPW & Touch screen controller & 48 \\
		STw4102 & Battery charger & 70 \\
		\hline
	\end{tabular}
	\caption{NHK8815 \icc device address map.}
	\label{table:i2c-device-addresses}
\end{tablehere}



%-------------------------------------------------------------------------------
\subsection{Project setup}
\label{sec:project_setup}

The first step to the project is to get the Linux kernel source and to configure
it for the target board. Instead of  using a vendor supplied kernel such as like
STLinux, my personal strategy for this project was to work with the official
kernel from \emph{www.kernel.org}.
This decision was motivated by the need to keep the development process as neat
as possible, and to avoid performing tasks that are not strictly concerned with
the project.

It should be noted that the official kernel offers only limited support for the
Nomadik  NHK8815 platform.
This includes basic definitions and register addresses, interrupt management,
resource definitions and timers. The \icc interface can be used through the
generic drivers \emph{i2c-gpio} and \emph{i2c-algo-bit}, but no one of the
NHK8815 \icc slave devices is provided.

I cloned the git repository at kernel.org on a local machine folder
located \underline{outside} the project workspace. From the tag \emph{3.3}
I created a new branch called \emph{i2cdevel}, where to commit the kernel updates.
I generated one patch per commit. All patches are numbered in sequence and
stored in a folder \underline{inside} the project workspace called
\emph{linux-3.3.0-patches}.

One benefit of this approach is that the project workspace, which is a git
repository as required, also holds all the data needed to obtain the modified
kernel from the official one.
Table \ref{table:project-dir-layout} shows the project workspace layout.
In addition, to ease the project management I defined a set of environmental
variables. A list of them with their definition is presented in table
\ref{table:project-env-variables}.

Finally, one note about the root filesystem. It was build using BusyBox
(version 1.18.4). More precisely, I used a tool called \textbf{bbfs 1.3}, 
developed by \emph{Alessandro Rubini} and released under GNU GPL license
(see \cite{bbfs1.3} for details).\\

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l p{5.5cm}}
		\hline
		Variable & Decription \\
		\hline
		\texttt{PRJROOT} & The project root \\
		\texttt{KERNELDIR} & The root directory of the kernel source tree \\
		\texttt{PATCHESDIR} & The \emph{linux-3.3.0-patches} directory \\
		\texttt{ROOTFS} & The directory that holds the root filesystem \\
		\texttt{MODULESDIR} & The directory for temporary holding of the
			loadable driver modules \\
		\hline
	\end{tabular}
	\caption{Project environmental variables.}
	\label{table:project-env-variables}
\end{tablehere}


\begin{table*}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{p{5cm} p{11cm}}
		\hline
		Directory & Content \\
		\hline
		\texttt{linux-3.3.0-patches} & The patches to the Linux kernel and the 
			kernel configuration file \emph{.config}\\
		\texttt{drivers} & The bus driver and slave driver (one subfolder per
			each driver) \\
		\texttt{report} & The \LaTeX sources of this paper \\
		\texttt{script} & Shell scripts (stored in the root folder of the target
			filesystem) \\
		\texttt{tools} & User-space programs to evaluate the drivers (stored in
			the root folder of the target filesystem) \\
		\texttt{images} & The binary image of the kernel and the root
			filesystem \\
		\hline
	\end{tabular}
	\caption{Project directory layout.}
	\label{table:project-dir-layout}
\end{table*}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{I2C client driver}
\label{sec:i2c_client_driver}
% TODO:
% x init & probe
% - sysfs
% - input polling
% - free-fall
% - platform data

This section describes the design of the driver for the LIS3LV02DL inertial
sensor which equips the NHK8815 evaluation board.
The LIS3LV02DL is a three axes linear accelerometer that provides the measurement acceleration signals to the external world through an \icc interface.
The LIS3LV02DL driver was written before the bus driver. Its debug was possible
by using the gpio-based \icc bus driver available in the original kernel. Once
completed and tested, the LIS3LV02DL driver was then used for debugging the new
STN8815 \icc bus driver.\\



%-------------------------------------------------------------------------------
\subsection{Initialization and probing}
\label{sec:lis3_init_probe}

During initialization the driver registers itself with the \icc core. This
is achieved by populating a \keyword{struct i2c\_driver} and passing it
as argument to the function \keyword{i2c\_add\_driver()}
\footnote{from the driver source code - file \emph{lis3lv02d-nhk8815.c}}.

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers=left,
]
/* Device and driver names */
#define	DEVICE_NAME		"lis3lv02d"

/* I2C client structure */
static struct i2c_device_id lis3lv02d_idtable[] = {
  { DEVICE_NAME, 0 },
  {}
};
MODULE_DEVICE_TABLE(i2c, lis3lv02d_idtable);

static struct i2c_driver lis3lv02d_driver = {
  .driver   = {
    .name = DRIVER_NAME
  },
  .probe    = lis3lv02d_probe,
  .remove   = __devexit_p(lis3lv02d_remove),
  .id_table = lis3lv02d_idtable,
};

/* Module init */
static int __init lis3lv02d_init(void)
{
  return i2c_add_driver(&lis3lv02d_driver);
}
\end{lstlisting}

The structure \keyword{i2c\_driver} holds pointers to the probe function
and to the remove function that are executed respectively on device probing
and when the device is removed (if ever).
The \keyword{id\_table} member of the structure \keyword{i2c\_driver} informs
the \icc framework about which slave devices are supported by the driver.
In this case the only chip supported is named \keyword{lis3lv02d}.
The names of the supported devices are important for \emph{binding}, as
explained next.

The binding process consists of associating a device with a driver that can
control it. In embedded systems where the number of the \icc bus and the
devices connected to it are known for a fact, it is possible to declare in
advance the \icc slaves which live on the bus. This is typically done in the
board setup file, as shown below
\footnote{from the NHK8815 setup source code - file \emph{board-nhk8815.c}}:

\begin{lstlisting}[
	xleftmargin=15pt,
	frame = l,
	numbers = left,
]
/* I2C devices */
static struct i2c_board_info nhk8815_i2c_devices[] = {
  {
    I2C_BOARD_INFO("lis3lv02d", 0x1D),
    .irq = NOMADIK_GPIO_TO_IRQ(82),
    /* No platform data: use driver defaults */
  },
};

static void __init nhk8815_platform_init(void)
{
  ...
  /* Register I2C devices on bus #0 (scl0, sda0) */
  i2c_register_board_info(0, nhk8815_i2c_devices,
    ARRAY_SIZE(nhk8815_i2c_devices));
  ...
}
\end{lstlisting}

The \keyword{nhk8815\_platform\_init} function is executed on board startup
and, among other tasks, registers the \icc slave devices by invoking the
\keyword{i2c\_register\_board\_info} function with arguments that specify
the number of the bus (zero in this case) and the devices connected with it.
This is done through an array of \keyword{struct i2c\_board\_info}, each item
of which specify the device name and the device address, with the former that
must match with the name registered by the driver for successful binding.
In this case \keyword{struct i2c\_board\_info} holds only one item which
corresponds to the LIS3LV02DL inertial sensor. Seeing that this sensor's chip
has an interrupt line tied to the cpu (gpio 82), the \keyword{irq} member is
also specified with the corresponding IRQ number. By means of another member
called \keyword{platform\_data} it is possible to define custom data for the
driver; if not specified like in this case, the driver uses its default
settings, as explained later on this paper.

During boot the kernel looks for any \icc driver that has registered a matching
device name, that is "lis3lv02d". Upon finding such a driver, the kernel
ivokes its \keyword{probe()} function passing a pointer to the LIS3LV02DL
device as a parameter. This process is called \emph{probing}.

The probe function is responsible for the per-device initialization, that is
initializing hardware, allocating resources, and registering the device with
any appropriate subsystems. More in detail, the LIS3LV02DL probe function
takes the following actions:
\begin{packedenum}
	\item Allocate memory for a \keyword{struct lis3lv02d\_priv} private data
		structure.
	\item Load the device's platform data.
	\item Idendify the LIS3LV02DL chip.
	\item Configure the device hardware.
	\item Create the per-device sysfs nodes.
	\item If the free-fall feature is enadled, request the interrupt and
		register the IRQ for the free-fall detection.
	\item If the device polling feature is enabled, register the device with
		the input subsystem.
\end{packedenum}
On successful completion of all the above steps, meaning a successful probing,
the device is bound to the driver.


%-------------------------------------------------------------------------------
\subsection{Sysfs interface}
\label{sec:lis3_sysfs}

Sysfs is an in-memory virtual filesystem that provides a view of the kernel's
structured device model. It offers a convenient yet simple way to implement
functionality as sysfs attribute in the appropriate directory. An attribute
provides a way to map kernel data to files in sysfs: a single attribute maps to
a single file which can be either readable, writable or both, depending on which
functionality it exports.

A driver wishing to use sysfs needs to register the sysfs attributes and implement
their respective functions. The table \ref{table:lis3-sysfs-attributes} shows
the list of sysfs nodes handled by the LIS3LV02D driver. They are located in
\keyword{/sys/devices/platform/lis3lv02d/}.

\begin{tablehere}
	\centering
	\renewcommand{\arraystretch}{1.2}	
	\begin{tabular}{l c p{4cm}}
		\hline
		Attribute & Access & Function \\
		\hline
		\texttt{position} & r & Show the acceleration along the x,y,z axis \\
		\hline
		\texttt{enable} & r & Show the enable status of the device \\
						& w & Enable/disable the device \\
		\hline
		\texttt{ff\_enable} & r & Show the enable status of the free-fall 
					 			  feature \\
		\hline
		\texttt{poll\_enable} & r & Show the enable status of the polling
									feature \\
							  & w & Enable/disable the device polling \\
		\hline
		\texttt{read} & r & Read the register at the current address \\
					  & w & Set the current address for reading \\
		\hline
		\texttt{write} & w & Write a register. The low byte holds the register
							 value and the high byte holds the register address \\
		\hline
	\end{tabular}
	\caption{LIS3LV02D sysfs attributes.}
	\label{table:lis3-sysfs-attributes}
\end{tablehere}

The figure \ref{fig:lis3-sysfs} shows a
dump of a shell session executed on the target board, providing a short
demonstration of how to play with the LIS3LV02D sysfs interface.

\begin{figurehere}
 \centering
 \includegraphics[width=8cm, height=3.46cm]{./figures/lis3lv02d-sysfs.png}
 \caption{Example of using the LIS3LV02D sysfs interface.}
 \label{fig:lis3-sysfs}
\end{figurehere}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{I2C bus driver}
\label{sec:i2c_bus_driver}

Description of the implementation details of the stn8815 i2c bus driver.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tools}
\label{sec:tools}

Description of the tools and scripts used throughout the project.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

TODO.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Add all references without citing
%\nocite{_bibtexkey_}

% We suggest the use of JabRef for editing your bibliography file (Report.bib)
\bibliographystyle{splncs}
\bibliography{Report}

\end{multicols}
\end{document}
